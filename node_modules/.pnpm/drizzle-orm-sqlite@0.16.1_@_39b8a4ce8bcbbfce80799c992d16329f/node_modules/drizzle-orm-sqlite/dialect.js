"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLiteAsyncDialect = exports.SQLiteSyncDialect = exports.SQLiteDialect = void 0;
const drizzle_orm_1 = require("drizzle-orm");
const sql_1 = require("drizzle-orm/sql");
const columns_1 = require("./columns");
const table_1 = require("./table");
class SQLiteDialect {
    escapeName(name) {
        return `"${name}"`;
    }
    escapeParam(num) {
        return '?';
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? (0, drizzle_orm_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? (0, drizzle_orm_1.sql) ` where ${where}` : undefined;
        return (0, drizzle_orm_1.sql) `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return drizzle_orm_1.sql.fromList(setEntries
            .map(([colName, value], i) => {
            const col = table[drizzle_orm_1.Table.Symbol.Columns][colName];
            const res = (0, drizzle_orm_1.sql) `${new sql_1.Name(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, drizzle_orm_1.sql.raw(', ')];
            }
            return [res];
        })
            .flat(1));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? (0, drizzle_orm_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? (0, drizzle_orm_1.sql) ` where ${where}` : undefined;
        return (0, drizzle_orm_1.sql) `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .map(({ field }, i) => {
            const chunk = [];
            if (field instanceof sql_1.SQLResponse || field instanceof sql_1.SQL) {
                const query = field instanceof sql_1.SQLResponse ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new sql_1.SQL(query.queryChunks.map((c) => {
                        if (c instanceof columns_1.SQLiteColumn) {
                            return new sql_1.Name(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
            }
            else if (field instanceof drizzle_orm_1.Column) {
                if (isSingleTable) {
                    chunk.push(new sql_1.Name(field.name));
                }
                else {
                    chunk.push(field);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push((0, drizzle_orm_1.sql) `, `);
            }
            return chunk;
        })
            .flat(1);
        return drizzle_orm_1.sql.fromList(chunks);
    }
    buildSelectQuery({ fields, where, table, joins, orderBy, groupBy, limit, offset }) {
        const joinKeys = Object.keys(joins);
        const selection = this.buildSelection(fields, { isSingleTable: joinKeys.length === 0 });
        const joinsArray = [];
        joinKeys.forEach((tableAlias, index) => {
            if (index === 0) {
                joinsArray.push((0, drizzle_orm_1.sql) ` `);
            }
            const joinMeta = joins[tableAlias];
            const table = joinMeta.table;
            const tableName = table[drizzle_orm_1.Table.Symbol.Name];
            const origTableName = table[table_1.SQLiteTable.Symbol.OriginalName];
            const alias = tableName === origTableName ? undefined : tableAlias;
            joinsArray.push((0, drizzle_orm_1.sql) `${drizzle_orm_1.sql.raw(joinMeta.joinType)} join ${new sql_1.Name(origTableName)} ${alias && new sql_1.Name(alias)} on ${joinMeta.on}`);
            if (index < joinKeys.length - 1) {
                joinsArray.push((0, drizzle_orm_1.sql) ` `);
            }
        });
        const joinsSql = drizzle_orm_1.sql.fromList(joinsArray);
        const whereSql = where ? (0, drizzle_orm_1.sql) ` where ${where}` : undefined;
        const orderByList = [];
        orderBy.forEach((orderByValue, index) => {
            orderByList.push(orderByValue);
            if (index < orderBy.length - 1) {
                orderByList.push((0, drizzle_orm_1.sql) `, `);
            }
        });
        const groupByList = [];
        groupBy.forEach((groupByValue, index) => {
            groupByList.push(groupByValue);
            if (index < groupBy.length - 1) {
                groupByList.push((0, drizzle_orm_1.sql) `, `);
            }
        });
        const groupBySql = groupByList.length > 0 ? (0, drizzle_orm_1.sql) ` group by ${drizzle_orm_1.sql.fromList(groupByList)}` : undefined;
        const orderBySql = orderByList.length > 0 ? (0, drizzle_orm_1.sql) ` order by ${drizzle_orm_1.sql.fromList(orderByList)}` : undefined;
        const limitSql = limit ? (0, drizzle_orm_1.sql) ` limit ${limit}` : undefined;
        const offsetSql = offset ? (0, drizzle_orm_1.sql) ` offset ${offset}` : undefined;
        return (0, drizzle_orm_1.sql) `select ${selection} from ${table}${joinsSql}${whereSql}${groupBySql}${orderBySql}${limitSql}${offsetSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[drizzle_orm_1.Table.Symbol.Columns];
        const colEntries = isSingleValue
            ? Object.keys(values[0]).map((fieldName) => [fieldName, columns[fieldName]])
            : Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => new sql_1.Name(column.name));
        values.forEach((value, valueIndex) => {
            const valueList = [];
            colEntries.forEach(([fieldName, col]) => {
                const colValue = value[fieldName];
                if (typeof colValue === 'undefined') {
                    let defaultValue;
                    if (col.default !== null && col.default !== undefined) {
                        if (col.default instanceof sql_1.SQL) {
                            defaultValue = col.default;
                        }
                        else {
                            defaultValue = (0, drizzle_orm_1.param)(col.default, col);
                        }
                    }
                    else {
                        defaultValue = (0, drizzle_orm_1.sql) `null`;
                    }
                    valueList.push(defaultValue);
                }
                else {
                    valueList.push(colValue);
                }
            });
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push((0, drizzle_orm_1.sql) `, `);
            }
        });
        const valuesSql = drizzle_orm_1.sql.fromList(valuesSqlList);
        const returningSql = returning
            ? (0, drizzle_orm_1.sql) ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? (0, drizzle_orm_1.sql) ` on conflict ${onConflict}` : undefined;
        return (0, drizzle_orm_1.sql) `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
        });
    }
}
exports.SQLiteDialect = SQLiteDialect;
class SQLiteSyncDialect extends SQLiteDialect {
    migrate(migrations, session) {
        var _a;
        const migrationTableCreate = (0, drizzle_orm_1.sql) `CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at numeric
		)`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values((0, drizzle_orm_1.sql) `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
        const lastDbMigration = (_a = dbMigrations[0]) !== null && _a !== void 0 ? _a : undefined;
        session.run((0, drizzle_orm_1.sql) `BEGIN`);
        try {
            for (const migration of migrations) {
                if (!lastDbMigration || parseInt(lastDbMigration[2], 10) < migration.folderMillis) {
                    session.exec(migration.sql);
                    session.run((0, drizzle_orm_1.sql) `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                }
            }
            session.run((0, drizzle_orm_1.sql) `COMMIT`);
        }
        catch (e) {
            session.run((0, drizzle_orm_1.sql) `ROLLBACK`);
            throw e;
        }
    }
}
exports.SQLiteSyncDialect = SQLiteSyncDialect;
class SQLiteAsyncDialect extends SQLiteDialect {
    migrate(migrations, session) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const migrationTableCreate = (0, drizzle_orm_1.sql) `CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at numeric
		)`;
            yield session.run(migrationTableCreate);
            const dbMigrations = yield session.values((0, drizzle_orm_1.sql) `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
            const lastDbMigration = (_a = dbMigrations[0]) !== null && _a !== void 0 ? _a : undefined;
            yield session.run((0, drizzle_orm_1.sql) `BEGIN`);
            try {
                for (const migration of migrations) {
                    if (!lastDbMigration || parseInt(lastDbMigration[2], 10) < migration.folderMillis) {
                        yield session.run(drizzle_orm_1.sql.raw(migration.sql));
                        yield session.run((0, drizzle_orm_1.sql) `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                    }
                }
                yield session.run((0, drizzle_orm_1.sql) `COMMIT`);
            }
            catch (e) {
                yield session.run((0, drizzle_orm_1.sql) `ROLLBACK`);
                throw e;
            }
        });
    }
}
exports.SQLiteAsyncDialect = SQLiteAsyncDialect;
//# sourceMappingURL=dialect.js.map