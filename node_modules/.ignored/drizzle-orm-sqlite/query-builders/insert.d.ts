import { Param, Placeholder, Query, SQL, SQLWrapper } from 'drizzle-orm/sql';
import { SQLiteDialect } from '../dialect';
import { IndexColumn } from '../indexes';
import { SelectFieldsOrdered, SelectResultFields, SQLiteSelectFields } from '../operations';
import { PreparedQuery, SQLiteSession } from '../session';
import { AnySQLiteTable, InferModel } from '../table';
import { SQLiteUpdateSetSource } from './update';
export interface SQLiteInsertConfig<TTable extends AnySQLiteTable = AnySQLiteTable> {
    table: TTable;
    values: Record<string, Param | SQL>[];
    onConflict?: SQL;
    returning?: SelectFieldsOrdered;
}
export declare type SQLiteInsertValue<TTable extends AnySQLiteTable> = {
    [Key in keyof InferModel<TTable, 'insert'>]: InferModel<TTable, 'insert'>[Key] | SQL | Placeholder;
};
export declare class SQLiteInsertBuilder<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult> {
    protected table: TTable;
    protected session: SQLiteSession;
    protected dialect: SQLiteDialect;
    constructor(table: TTable, session: SQLiteSession, dialect: SQLiteDialect);
    protected mapValues(values: SQLiteInsertValue<TTable>[]): Record<string, Param<unknown, unknown> | SQL>[];
    values(...values: SQLiteInsertValue<TTable>[]): SQLiteInsert<TTable, TResultType, TRunResult>;
}
export interface SQLiteInsert<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> extends SQLWrapper {
}
export declare class SQLiteInsert<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> implements SQLWrapper {
    private session;
    private dialect;
    protected $table: TTable;
    private config;
    constructor(table: TTable, values: SQLiteInsertConfig['values'], session: SQLiteSession, dialect: SQLiteDialect);
    returning(): Omit<SQLiteInsert<TTable, TResultType, TRunResult, InferModel<TTable>>, 'returning' | `onConflict${string}`>;
    returning<TSelectedFields extends SQLiteSelectFields>(fields: TSelectedFields): Omit<SQLiteInsert<TTable, TResultType, TRunResult, SelectResultFields<TSelectedFields>>, 'returning' | `onConflict${string}`>;
    onConflictDoNothing(config?: {
        target?: IndexColumn | IndexColumn[];
        where?: SQL;
    }): this;
    onConflictDoUpdate(config: {
        target?: IndexColumn | IndexColumn[];
        where?: SQL;
        set: SQLiteUpdateSetSource<TTable>;
    }): this;
    toSQL(): Query;
    prepare(): PreparedQuery<{
        type: TResultType;
        run: TRunResult;
        all: TReturning extends undefined ? never : TReturning[];
        get: TReturning extends undefined ? never : TReturning;
        values: TReturning extends undefined ? never : any[][];
    }>;
    run: ReturnType<this['prepare']>['run'];
    all: ReturnType<this['prepare']>['all'];
    get: ReturnType<this['prepare']>['get'];
    values: ReturnType<this['prepare']>['values'];
}
//# sourceMappingURL=insert.d.ts.map